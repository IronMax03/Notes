\documentclass[5pt]{article}
\usepackage{multicol,multirow}
\usepackage{graphicx} % Required for inserting images
\usepackage[margin=0.45cm]{geometry}
\usepackage{xcolor}
\usepackage{array}

\definecolor{LightGray}{gray}{0.9}
\usepackage[inline]{enumitem}
\usepackage{minted}

\begin{document}
\begin{center}
     \Large{\textbf{C\texttt{++} Cheat Sheet}}\\
     \small{Class: CSCI 1300}\hfill\small{\textcopyright Maximilien Notz \the\year{}}
     \noindent\rule{20cm}{0.4pt}
\end{center}
\begin{multicols}{2}
\setcounter{secnumdepth}{0}


\subsection{General Reminders}
\begin{tabular}{>{\small\ttfamily}l l}

\#include "myfile.h"    & Include file.\\
rand()                  & Random int, \texttt{\#include<cstdlib>}.\\
int(var)                & Convert a data type var to int.\\
float(var)              & Convert a data type var to float.\\
double(var)             & Convert a data type var to double.\\
static\_cast<t>(var)    & Convert \texttt{var} to the type \texttt{t}.\\
void myF() const        & read only fonction.\\
inline                  & the whole code of the inline function is\\
                        & inserted or substituted at the point of its\\
                        & call during the compilation.\\
constexpr               & that specify that an expression must be\\
                        & evaluated at compile time.\\
sizeof(var)             & return the number of bytes used by the\\
                        & variable. \texttt{sizeof} runs at compile-time.\\
move(obj)               & During assignation move the already\\
                        & existing object instead of creating a\\
                        & copy of it (memory optimizations).\\      
ternary Opearator       & condition ? ifTrue : ifFalse\\
\end{tabular}


\subsection{Strings}
\begin{tabular}{>{\ttfamily}l l}
str$[$i$]$          & Get or set the char at the index \texttt{i}.\\
.length()           & Return the number of characters.\\
.substr(a,b)        & Returns the substring starting at index \texttt{a}\\
                    & with length \texttt{b}.\\
.find(subStr)       & Return the start index of the substring\\
.replace(i,l,str)   & Replace $l$ characters starting at index \texttt{i}\\
                    & with \texttt{str}.\\
\#include <string>  & all the above must include string.\\
stoi(str)           & Convert a string to int.\\
stof(str)           & Convert a string to float,\\
stod(str)           & Convert a string to double,\\
to\_string(var)     & Convert var to a string,\\
\end{tabular}

\subsection{Vectors}
\begin{tabular}{>{\ttfamily}l l}
\#include<vector>           & Include vector library. \\
vector<type> V;             & Instantiate a vector. \\
vector<type> V(s);          & Instantiate a vector of size \texttt{s}. \\
vector<type> V\{6,3,3\};    & Instantiate a vector from Array. \\
vector<type> V(s, var);     & Instantiate a vector of size \texttt{s} with \\
                            & all elements initialized to \texttt{var}. \\
.at(i)                      & Returns the element at index \texttt{i}. \\
.size()                     & Return the number of elements. \\
.push\_back(Value)          & Add the new element at the end. \\
.pop\_back()                & Remove the last element. \\
.clear()                    & Empty the vector. \\
.insert(i, Value)           & Insert \texttt{Value} at \texttt{i}. \\
.reserve(int)               & Pre-allocate memory for perf. \\
                            & when the max size is known. \\
\end{tabular}

\subsection{Arrays}
\begin{tabular}{c|c|c|c }
 0 & 1 & … & n \\ 
 \hline
 "Max" & "Tom" & … & arr$[$n$]$
\end{tabular}
This table illustrate the structure of an array of strings. Considering that n is equal to the number of element minus one. Arrays are a static data type.\\[6pt]
\begin{tabular}{>{\ttfamily}l l}
int arr[4];         & Create a array of int and with 4 element.\\
int arr[4]=\{6,3\}; & \\
arr$[$i$]$          & Get or set the element at the index i.\\
\end{tabular}


\subsection{Structures}
\begin{minted}[bgcolor=LightGray]{C++}
struct myStruct {
    string param1;    // atribute 1
    double param2;   // atribute 2
}s1, s2;            // myStruct instances
\end{minted}
\begin{tabular}{>{\ttfamily}l l}
myStruct Obj;   & instantiate structure object. \\
Obj.param1      & Access param1 of \texttt{Obj}. \\
\end{tabular}


\subsection{Streams}
\begin{tabular}{>{\ttfamily}l l}

\#include<fstream>      & Include stream library. \\
\#include<sstream>      & Include string stream library. \\
ifstream fin;           & Instantiate a input stream. \\
ofstream fout;          & Instantiate a output stream. \\
stringstream s(str);  & Instantiate a string stream. \\
myS.open("file.txt")    & Open txt file whith the stream. \\
myS.close()             & Close the stream file. \\
getline(fin, line)      & Get the next line from fin. \\
fout<<"hello"           & Output in stream "helloWorld". \\
fin>>var                & Input from stream to var. \\
%% streams manipulators
<<setprecision(n)<<     & Set decimal points, \texttt{\#include<iomanip>}. \\
<<setw(n)<<             & Establishes a print field of n spaces. \\
<<fixed<<               & Display floating point numbers in fixed. \\
                        & point notation. \\
<<showpoint<<           & Enables or disables the unconditional \\
<<noshowpoint<<         & inclusion of the decimal point character \\
                        & in floating-point output. \\
<<left<<                & output the string on the left. \\
<<right<<               & output the string on the right. \\
\end{tabular}

\subsubsection{clear buffer}
The buffer must be cleared after after getting an input from a stream if you input and output in the same file at the same time. 
\begin{minted}[bgcolor=LightGray]
{c++}
if(cin.fail() == true) {
    cin.clear(); 
    cin.ignore(1000, '\n'); 
}
\end{minted}

\subsection{Error Handling}
\begin{minted}[bgcolor=LightGray]{C++}
try {
    // risky operation
} catch (exceptions) {
    // runs if an exception of type Ex is thrown
}
\end{minted}
\begin{tabular}{>{\ttfamily}l l}
\#include<cassert>          & Include assert library.\\
\#include<stdexcept>        & Common standard exceptions.\\
throw myException           & Throw an error of type myException.\\
exception::what()           & Retrieve diagnostic message.\\
catch (const auto\& e)      & Catch exceptions by const reference.\\
catch(...)                  & Fallback handler; rethrow if unsure.\\
exception                   & Parent of all exceptions class.\\
\end{tabular}

\subsection{Object Oriented Programing(OOP)}
\begin{minted}[bgcolor=LightGray, escapeinside=§§, mathescape=true,]
{c++}
class myClasses :public parentClass{
    private:
        // private methods and variables
    public:
        // public methods and variables

        myClasses(int p1, int p2){§$\dots$§} // Constructor

        ~myClasses(){§$\dots$§} // Destructor

        // Override the inherited method parentMethod()
        void parentMethod() override { ... }

        //Example Operator Overloading
        Number operator+(const Number &n){
            return Number(value + n.value);
        }
};
\end{minted}
\begin{tabular}{>{\ttfamily}l l}

myClasses myObj(3,5);   & Instantiate an myClasses type obj.\\
myClasses myObj;        & Call the default constructor.\\
protected:              & similar to private, but it can also be\\
                        & accessed in the inherited class.\\
virtual                 & Specify that a method can be overridden\\
                        & in a derived class.\\
\end{tabular}

\subsection{OOP With header file}
If you use a header the file wich contain the main function must include the header file.
\subsubsection{Header file(myHeader.h)}

\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]{c++}
#ifndef MYCLASS_H //if no def for MyClass
#define MYCLASS_H //else

using namespace std;

class MyClass{
    public:
        §$\vdots$§
    private:
        §$\vdots$§
};
#endif
\end{minted}
\subsubsection{Class file(.cpp)}
\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]{c++}
#include "myHeader.h"

MyClass::MyClass(int p1, §$\dots$§){
    publicAtribute = p1;
    §$\vdots$§
}
\end{minted}

\subsection{Genericity}
\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]{c++}
    template <typename T_1, §$\dots$§, typename T_n>
    class myClasse{
        §$\vdots$§
\end{minted}

\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]{c++}
myClasse<T_1, §$\dots$§, T_n>(§$\dots$§);
\end{minted}


\subsection{Switch case}
\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]
{c++}
switch (x){
    case 0:
        /*Code in case x = 0*/
    break;
        §$\vdots$§
    case n:
        /*Code in case x = n*/
    break;
    default:
        /*Code if no case match*/
}
\end{minted}

\subsection{Pointer \& References}
\begin{tabular}{>{\ttfamily}l l}    
    int* myInt;             & * means myInt work form a pointer.\\
    new                     & dynamically allocate a block of memory.\\
    delete                  & release dynamically allocated memory.\\
    NULL                    & Macro that referens to null pointer.\\
    $*$var                  & Get var value, where var is a pointer.\\
    \&var                   & Get memory addresse of \textbf{var}.\\
    void* var               & Pointer with no associated data type.\\
\end{tabular}

\subsection{Bitwise Operators}
\begin{tabular}{>{\ttfamily}l l | >{\ttfamily}l l |  >{\ttfamily}l l }
\&           & Bitwise AND. & \textasciitilde  & Bitwise NOT. & \textasciicircum & Bitwise XOR.\\
$|$          & Bitwise OR. & $<<$         & Left shift. &  $>>$         & Right shift.\\\
\end{tabular}


\subsection{Namespaces}
\begin{tabular}{>{\small\ttfamily}l l}
namespace NS \{...\}      & Define a namespace.\\
NS::func()                & Access member of namespace.\\
using namespace NS;       & Import all names from namespace.\\
using NS::func;           & Import specific name from \texttt{NS}.\\
namespace \{...\}           & Anonymous namespace: limits scope\\
                            & to current translation unit (file).\\
inline namespace NS \{...\} & Members are accessible without\\
                            & qualification by default.\\
namespace alias = NS;     & Create an alias for a namespace.\\
::globalVar                 & Access global namespace explicitly.\\
\end{tabular}

\subsection{Lambda Expression}
\begin{minted}[escapeinside=§§, mathescape=true, bgcolor=LightGray]{c++}
    ... = [captureClause] (parameters) -> returnType { 
    // definition}
\end{minted}
\begin{tabular}{>{\ttfamily}l l}
    $[\&]$                  & capture all external variables by reference.\\
    $[=]$                   & capture all external variables by value.\\
    $[a, \&b]$              & capture 'a' by value and 'b' by reference.\\
\end{tabular}

\subsection{cmath}
\begin{tabular}{>{\ttfamily}l l}
\#include<cmath>        & Include cmath library. \\
sqrt(x)                 & Square root of \texttt{x}. \\
pow(x, y)               & \texttt{x} raised to the power \texttt{y}. \\
abs(x)                  & Absolute value overloads. \\
floor(x)                & Greatest integer $\leq$ \texttt{x}. \\
ceil(x)                 & Smallest integer $\geq$ \texttt{x}. \\
fmod(x, y)              & Floating-point remainder of \texttt{x}$/$\texttt{y}. \\
\end{tabular}

\subsection{Special Ints}
\textbf{signed fixed width integer types}\\
\begin{tabular}{>{\small\ttfamily}l >{\small\ttfamily}l >{\small\ttfamily}l >{\small\ttfamily}l}
int8\_t         & int16\_t          & int32\_t          & int64\_t          \\
int\_fast8\_t   & int\_fast16\_t    & int\_fast32\_t    & int\_fast64\_t    \\
int\_least8\_t  & int\_least16\_t   & int\_least32\_t   & int\_least64\_t   \\
\end{tabular}
\textbf{unsigned fixed width integer types}\\
\begin{tabular}{>{\small\ttfamily}l >{\small\ttfamily}l >{\small\ttfamily}l >{\small\ttfamily}l}
uint8\_t        & uint16\_t         & uint32\_t         & uint64\_t         \\
uint\_fast8\_t  & uint\_fast16\_t   & uint\_fast32\_t   & uint\_fast64\_t   \\
uint\_least8\_t & uint\_least16\_t  & uint\_least32\_t  & uint\_least64\_t  \\
\end{tabular}
\textbf{other integer types}\\
\begin{tabular}{>{\small\ttfamily}r l}
    intmax\_t \& uintmax\_t & Maximum-width integer type.\\
    intptr\_t \& uintptr\_t & Integer types capable of storing a pointer\\
                            & value.\\
    size\_t & An unsigned integer data type to\\
            & represent the size of objects in bytes;\\
            & commonly used for array indexing\\
            & and loop counters.\\  
\end{tabular}  

\subsection{Preprocessing}
\begin{tabular}{>{\ttfamily}l l}
\#define NAME value    & Define a macro.\\
\#define F(x) x*x      & Define a function-like macro.\\
\#ifdef NAME          & If the macro \texttt{NAME} is defined.\\
\#ifndef NAME         & If the macro \texttt{NAME} is not defined.\\
\#else               & Alternative case for ifdef/ifndef.\\
\#endif              & End conditional directive.\\
\#include            & Include a file.\\
\_\_FILE\_\_         & Current file name.\\
\_\_LINE\_\_         & Current line number.\\
\_\_DATE\_\_         & Compilation date.\\
\_\_TIME\_\_         & Compilation time.\\
\#pragma             & Implementation-specific instruction.\\
\end{tabular}
\begin{itemize*}
    \item \texttt{once} — simple include guard for header files.
    \item \texttt{pack(push, n)} / \texttt{\#pragma pack(pop)} — set and restore struct packing/alignment to n bytes.
    \item \texttt{pack(n)} — set struct member alignment to n.
    \item \texttt{GCC optimize("...")} — enable compiler-specific optimizations (GCC/Clang).
    \item \texttt{\#pragma warning(push)} / \texttt{\#pragma warning(pop)} / \texttt{\#pragma warning(disable:NNNN)} — control MSVC warnings.
    \item \texttt{\#pragma message("text")} — emit a compile-time message.
    \item \texttt{\#pragma comment(lib, "name.lib")} — instruct MSVC linker to link a library.
\end{itemize*}

\subsection{Compiler Commends}
\begin{tabular}{>{\small\ttfamily}ll}
    clang++ filesName   & commend to compile c++ code with \textbf{clang},\\
                        & clang is a LLVM compiler.\\
    -o name             & define the name of the compiled object.\\ 
    -v                  & Makes the compiler print detailed\\
                        & information. "v" stands for "Verbose".\\
    -E                  & Prints the preprocessor output.\\
    -Wall               & activates all warnings\\
    -Wextra             & Enable extra warnings beyond \texttt{-Wall}.\\
    -c filesName        & generate an object file. To add \texttt{.o} filse to\\
                        & the compilation simply add those like a\\
                        & regular file.\\  
    -O0, -O1,           & Optimizations levels, where \texttt{-O0} is not\\
    -O2, -O3,           & optimization\\
    -Ofast
\end{tabular}

\end{multicols}
\end{document}
